{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":""},{"location":"#description","title":"Description","text":"<p>CONCORD (COntrastive learNing for Cross-dOmain Reconciliation and Discovery) is a novel machine learning framework that leverages contrastive learning, masked autoencoders, and a unique batch construction strategy using data-aware sampling. CONCORD learns an encoding of cells that captures the cell state manifold, revealing both local and global structures. The resulting high-resolution atlas of cell states and trajectories is coherent across different domains, such as batches, technologies, and species. </p> <p>Full Documentation available at [insert documentation link].</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#1-clone-the-concord-repository-and-set-up-environment","title":"1. Clone the Concord repository and set up environment:","text":"<pre><code>git clone git@github.com:Gartner-Lab/Concord.git\n</code></pre> <p>It is recommended to use conda (https://conda.io/projects/conda/en/latest/user-guide/install/index.html) to create and set up virtual environment for Concord.</p>"},{"location":"#2-install-pytorch","title":"2. Install PyTorch:","text":"<p>You must install the correct version of PyTorch based on your system's CUDA setup. Please follow the instructions on the official PyTorch website to install the appropriate version of PyTorch for CUDA or CPU.</p> <p>Example (for CPU version): <pre><code>pip install torch torchvision torchaudio\n</code></pre></p>"},{"location":"#3-install-dependencies","title":"3. Install dependencies:","text":"<p>Navigate to the Concord directory and install the required dependencies:</p> <pre><code>cd path_to_Concord\npip install -r requirements.txt\n</code></pre>"},{"location":"#4-install-concord","title":"4. Install Concord:","text":"<p>Build and install Concord:</p> <pre><code>python setup.py sdist bdist_wheel\npip install dist/Concord-0.8.0-py3-none-any.whl\n</code></pre>"},{"location":"#5-optional-install-faiss-for-accelerated-knn-search-not-recommended-for-mac","title":"5. (Optional) Install FAISS for accelerated KNN search (not recommended for Mac):","text":"<p>Install FAISS for fast nearest-neighbor searches for large datasets. Note if you are using Mac, you should turn faiss off by specifying <code>cur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, use_faiss=False, device=device)</code> when running Concord, unless you are certain faiss runs with no problem.</p> <ul> <li>FAISS with GPU:   <pre><code>pip install faiss_gpu\n</code></pre></li> <li>FAISS with CPU:   <pre><code>pip install faiss_cpu\n</code></pre></li> </ul>"},{"location":"#6-optional-install-optional-dependencies","title":"6. (Optional) Install optional dependencies:","text":"<p>Concord offers additional functionality through optional dependencies. You can install them via: <pre><code>pip install -r requirements_optional.txt\n</code></pre></p>"},{"location":"#7-optional-integration-with-viscello","title":"7. (Optional) Integration with VisCello:","text":"<p>Concord integrates with VisCello, a tool for interactive visualization. To explore results interactively, visit VisCello GitHub and refer to the full documentation for more information.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The ipython notebook of this example can be found at Tutorial: PBMC3k dataset, single batch.</p>"},{"location":"#run-concord","title":"Run Concord","text":"<p>Concord seamlessly works with <code>anndata</code> objects. Here\u2019s an example run:</p> <pre><code>import Concord as ccd\nimport scanpy as sc\nimport torch\n\nadata = sc.datasets.pbmc3k_processed()\nadata = adata.raw.to_adata()  # Store raw counts in adata.X, by default Concord will run standard total count normalization and log transformation internally\n\n# Set device to cpu or to gpu (if your torch has been set up correctly to use GPU)\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n\n# Select top variably expressed/accessible features for analysis (other methods besides seurat_v3 available)\nfeature_list = ccd.ul.select_features(adata, n_top_features=5000, flavor='seurat_v3')\n\n# Initialize Concord with an AnnData object, skip input_feature default to all features\ncur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, device=device) \n# If integrating data across batch, simply add the domain_key argument\n# cur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, domain_key='batch', device=device) \n\n# Encode data, saving the latent embedding in adata.obsm['Concord']\ncur_ccd.encode_adata(input_layer_key='X_log1p', output_key='Concord')\n</code></pre>"},{"location":"#visualize-results","title":"Visualize Results:","text":"<p>We recommend using UMAP to visualize Concord embeddings:</p> <pre><code>ccd.ul.run_umap(adata, source_key='Concord', umap_key='Concord_UMAP', n_components=2, n_neighbors=15, min_dist=0.1, metric='euclidean')\n\n# Plot the UMAP embeddings\ncolor_by = ['n_genes', 'louvain'] # Choose which variables you want to visualize\nccd.pl.plot_embedding(\n    adata, basis='Concord_UMAP', color_by=color_by, figsize=(10, 5), dpi=600, ncols=2, font_size=6, point_size=10, legend_loc='on data',\n    save_path='Concord_UMAP.png'\n)\n</code></pre>"},{"location":"#3d-visualization","title":"3D Visualization:","text":"<p>For complex structures, 3D UMAP may provide better insights:</p> <pre><code>ccd.ul.run_umap(adata, source_key='Concord', umap_key='Concord_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')\n\n# Plot the 3D UMAP embeddings\ncol = 'louvain'\nccd.pl.plot_embedding_3d(\n    adata, basis='Concord_UMAP_3D', color_by=col,\n    save_path='Concord_UMAP_3D.html',\n    point_size=10, opacity=0.8, width=1500, height=1000\n)\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>Concord is currently available on BioRxiv. Please cite the preprint here: [Insert citation link].</p>"},{"location":"about/","title":"About","text":""},{"location":"advanced/","title":"Advanced usage","text":""},{"location":"api/","title":"API","text":""},{"location":"framework/","title":"The Concord Framework","text":""},{"location":"notebooks/concord_Huycke/","title":"Intestine development by Huycke et al.","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import Concord as ccd\nimport scanpy as sc\nimport torch\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndata_path = \"../data/intestine_dev/intestine_adata.h5ad\"\nadata = sc.read(\n    data_path\n)\n\nadata.layers[\"counts\"] = adata.X.copy()\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nccd.ul.score_cell_cycle(adata, organism='Mm')\n</pre> import Concord as ccd import scanpy as sc import torch import warnings warnings.filterwarnings('ignore')  data_path = \"../data/intestine_dev/intestine_adata.h5ad\" adata = sc.read(     data_path )  adata.layers[\"counts\"] = adata.X.copy() sc.pp.normalize_total(adata) sc.pp.log1p(adata) ccd.ul.score_cell_cycle(adata, organism='Mm') <pre>Concord - INFO - Processed 43 human genes to mouse orthologs.\nConcord - INFO - Processed 54 human genes to mouse orthologs.\n</pre> In\u00a0[3]: Copied! <pre>import time\nfrom pathlib import Path\nproj_name = \"concord_Huycke_intestine\"\nsave_dir = f\"../save/dev_{proj_name}-{time.strftime('%b%d')}/\"\nsave_dir = Path(save_dir)\nsave_dir.mkdir(parents=True, exist_ok=True)\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\nfile_suffix = f\"{proj_name}_{time.strftime('%b%d')}\"\nseed = 0\n</pre> import time from pathlib import Path proj_name = \"concord_Huycke_intestine\" save_dir = f\"../save/dev_{proj_name}-{time.strftime('%b%d')}/\" save_dir = Path(save_dir) save_dir.mkdir(parents=True, exist_ok=True) device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu') file_suffix = f\"{proj_name}_{time.strftime('%b%d')}\" seed = 0 <p>Dropout is one of the major patterns in single cell data. Even nearby cells can have significant proportion of non-overlapping non-zero genes, which could be due to technical drop-out or real biology (genes stochastically turned on or off). Concord 'augments' the data by introducing dropout to each of the cell, and use contrastive learning to 'self-supervise' the model to learn the cell identity despite the presence of dropout. The augment dropout probability can be custom-defined, or be estimated based on the average dropout rate in the current data. Here we provide a detailed example how this is calculated:</p> In\u00a0[103]: Copied! <pre># Select top variably expressed/accessible features for analysis (other methods besides seurat_v3 available)\noutput_key = 'Concord'\nfeature_list = ccd.ul.select_features(adata, n_top_features=10000, flavor='seurat_v3')\n# Determine augmentation mask probabilities based on estimated dropout rate from knn neighbors\ndropout_est = ccd.ul.estimate_aug_mask_prob(adata, input_feature = feature_list, n_samples = adata.n_obs, return_mean=False, plotting=True)\n</pre> # Select top variably expressed/accessible features for analysis (other methods besides seurat_v3 available) output_key = 'Concord' feature_list = ccd.ul.select_features(adata, n_top_features=10000, flavor='seurat_v3') # Determine augmentation mask probabilities based on estimated dropout rate from knn neighbors dropout_est = ccd.ul.estimate_aug_mask_prob(adata, input_feature = feature_list, n_samples = adata.n_obs, return_mean=False, plotting=True)  <pre>Concord.utils.feature_selector - INFO - Selecting highly variable features with flavor seurat_v3...\n</pre> In\u00a0[86]: Copied! <pre># Save for concord run and visualization\nadata.obs['dropout_est'] = dropout_est\naug_prob = dropout_est.mean()\n</pre> # Save for concord run and visualization adata.obs['dropout_est'] = dropout_est aug_prob = dropout_est.mean() <p>Here's one specific example showing the gene set difference between a cell and its 3 nearest neighbors.</p> In\u00a0[73]: Copied! <pre>from Concord.model.knn import Neighborhood\nimport numpy as np\nemb = adata.obsm['X_pca']\nneighborhood = Neighborhood(emb=emb, k=3)\ncore_samples = np.array([9000])\nX = adata.X.toarray()\navg_distances = neighborhood.average_knn_distance(core_samples, X, k=3, distance_metric='drop_diff')\nprint(avg_distances)\nindices = neighborhood.get_knn_indices(core_samples, k=3, include_self=False)\nprint(adata.obs['cell_type'].iloc[core_samples])\nprint(adata.obs['cell_type'].iloc[indices.flatten()])\n</pre> from Concord.model.knn import Neighborhood import numpy as np emb = adata.obsm['X_pca'] neighborhood = Neighborhood(emb=emb, k=3) core_samples = np.array([9000]) X = adata.X.toarray() avg_distances = neighborhood.average_knn_distance(core_samples, X, k=3, distance_metric='drop_diff') print(avg_distances) indices = neighborhood.get_knn_indices(core_samples, k=3, include_self=False) print(adata.obs['cell_type'].iloc[core_samples]) print(adata.obs['cell_type'].iloc[indices.flatten()])  <pre>Concord.model.knn - INFO - Using FAISS CPU index.\nConcord.model.knn - INFO - Building Faiss FlatL2 index.\nConcord.model.knn - INFO - Using FAISS CPU index.\n</pre> Out[73]: <pre>array([0.4884242])</pre> In\u00a0[81]: Copied! <pre>import seaborn as sns\nimport sys\nsys.setrecursionlimit(10000)\nmtx = adata.X.toarray()\ncore_nonzero = (mtx[core_samples] &gt; 0)  # Boolean array for non-zero genes in core cells\nneighbor_nonzero = (mtx[indices] &gt; 0)   # Boolean array for non-zero genes in neighbors\ncbn_indices = np.concatenate([core_samples, indices.flatten()])\nsns.clustermap(mtx[cbn_indices], row_cluster=False, col_cluster=True, cmap='viridis', figsize=(7, 3))\n</pre> import seaborn as sns import sys sys.setrecursionlimit(10000) mtx = adata.X.toarray() core_nonzero = (mtx[core_samples] &gt; 0)  # Boolean array for non-zero genes in core cells neighbor_nonzero = (mtx[indices] &gt; 0)   # Boolean array for non-zero genes in neighbors cbn_indices = np.concatenate([core_samples, indices.flatten()]) sns.clustermap(mtx[cbn_indices], row_cluster=False, col_cluster=True, cmap='viridis', figsize=(7, 3)) Out[81]: <pre>&lt;seaborn.matrix.ClusterGrid at 0x7f22879c9c40&gt;</pre> In\u00a0[91]: Copied! <pre>cur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, domain_key='LaneID', \n                      latent_dim=32,\n                      augmentation_mask_prob = aug_prob, \n                      clr_temperature = .3, # Check out advanced usage to learn what this parameter controls\n                      min_p_intra_domain=1.0, \n                      seed=seed, \n                      inplace=False, \n                      verbose=True, \n                      device=device) \n\n# Encode data, saving the latent embedding in adata.obsm['Concord']\ncur_ccd.encode_adata(input_layer_key='X_log1p', output_key=output_key)\n\n# Save the latent embedding to a filem, so that it can be loaded later\nccd.ul.save_obsm_to_hdf5(cur_ccd.adata, save_dir / f\"obsm_{file_suffix}.h5\")\nadata.obsm = cur_ccd.adata.obsm # If not inplace\n</pre> cur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, domain_key='LaneID',                        latent_dim=32,                       augmentation_mask_prob = aug_prob,                        clr_temperature = .3, # Check out advanced usage to learn what this parameter controls                       min_p_intra_domain=1.0,                        seed=seed,                        inplace=False,                        verbose=True,                        device=device)   # Encode data, saving the latent embedding in adata.obsm['Concord'] cur_ccd.encode_adata(input_layer_key='X_log1p', output_key=output_key)  # Save the latent embedding to a filem, so that it can be loaded later ccd.ul.save_obsm_to_hdf5(cur_ccd.adata, save_dir / f\"obsm_{file_suffix}.h5\") adata.obsm = cur_ccd.adata.obsm # If not inplace <pre>Concord - INFO - Setting sampler_knn to 1309 to be 1/50 the number of cells in the dataset. You can change this value by setting sampler_knn in the configuration.\nConcord - INFO - Column 'LaneID' is already of type: category\nConcord - INFO - Unused levels dropped for column 'LaneID'.\nConcord - INFO - Encoder input dim: 10000\nConcord - INFO - Decoder input dim: 40\nConcord - INFO - Model loaded to device: cuda:0\nConcord - INFO - Total number of parameters: 2590128\nConcord.model.dataloader - INFO - Preprocessing adata...\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Skip normalization.\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Storing in the specified layer.\nConcord.utils.preprocessor - INFO - Filtering features with provided list (10000 features)...\nConcord.model.anndataset - INFO - Initialized dataset with 65468 samples. Data structure: ['input', 'domain', 'idx']\nConcord.model.dataloader - INFO - Using existing embedding 'X_pca' from adata.obsm\nConcord.model.knn - INFO - Using FAISS CPU index.\nConcord.model.knn - INFO - Building Faiss IVF index. nprobe=10\nConcord.model.knn - INFO - Using FAISS CPU index.\nConcord.model.dataloader - INFO - Number of unique_domains: 6\nConcord.model.dataloader - INFO - Calculating each domain's coverage of the global manifold using X_pca.\nConcord.model.dataloader - INFO - Converting coverage to p_intra_domain...\nConcord.model.dataloader - INFO - Final p_intra_domain values: L1: 1.00, L2: 1.00, R: 1.00, Live_1: 1.00, Live_2: 1.00, Rare: 1.00\nConcord - INFO - Starting epoch 1/5\nConcord - INFO - Processing chunk 1/1 for epoch 1\nConcord - INFO - Number of samples in train_dataloader: 65468\n</pre> <pre>Epoch 0 Training: 1020it [00:32, 31.28it/s, loss=3.05]</pre> <pre>Concord - INFO - Epoch   0 | Train Loss: 3.33, MSE: 0.09, CLASS: 0.00, CONTRAST: 3.24, IMPORTANCE: 0.00\nConcord - INFO - Starting epoch 2/5\nConcord - INFO - Processing chunk 1/1 for epoch 2\nConcord - INFO - Number of samples in train_dataloader: 65468\n</pre> <pre>\nEpoch 1 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1020/1020 [00:30&lt;00:00, 33.47it/s, loss=3.06]</pre> <pre>Concord - INFO - Epoch   1 | Train Loss: 2.99, MSE: 0.06, CLASS: 0.00, CONTRAST: 2.93, IMPORTANCE: 0.00\nConcord - INFO - Starting epoch 3/5\nConcord - INFO - Processing chunk 1/1 for epoch 3\nConcord - INFO - Number of samples in train_dataloader: 65468\n</pre> <pre>\nEpoch 2 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1020/1020 [00:27&lt;00:00, 36.61it/s, loss=2.94]</pre> <pre>Concord - INFO - Epoch   2 | Train Loss: 2.94, MSE: 0.06, CLASS: 0.00, CONTRAST: 2.88, IMPORTANCE: 0.00\nConcord - INFO - Starting epoch 4/5\nConcord - INFO - Processing chunk 1/1 for epoch 4\nConcord - INFO - Number of samples in train_dataloader: 65468\n</pre> <pre>\nEpoch 3 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1020/1020 [00:28&lt;00:00, 36.01it/s, loss=3.09]</pre> <pre>Concord - INFO - Epoch   3 | Train Loss: 2.91, MSE: 0.06, CLASS: 0.00, CONTRAST: 2.85, IMPORTANCE: 0.00\nConcord - INFO - Starting epoch 5/5\nConcord - INFO - Processing chunk 1/1 for epoch 5\nConcord - INFO - Number of samples in train_dataloader: 65468\n</pre> <pre>\nEpoch 4 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1020/1020 [00:29&lt;00:00, 34.81it/s, loss=3.05]</pre> <pre>Concord - INFO - Epoch   4 | Train Loss: 2.89, MSE: 0.06, CLASS: 0.00, CONTRAST: 2.83, IMPORTANCE: 0.00\n</pre> <pre>\n</pre> <pre>Concord - INFO - Model saved to save/final_model.pth\nConcord - INFO - Final model saved at: save/final_model.pth; Configuration saved at: save/config.json.\nConcord.model.dataloader - INFO - Preprocessing adata...\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Skip normalization.\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Storing in the specified layer.\nConcord.utils.preprocessor - INFO - Filtering features with provided list (10000 features)...\nConcord.model.anndataset - INFO - Initialized dataset with 65468 samples. Data structure: ['input', 'domain', 'idx']\nConcord - INFO - Predicting for chunk 1/1\n</pre> In\u00a0[100]: Copied! <pre>#ccd.ul.run_umap(adata, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed)\nshow_basis = f'{output_key}_UMAP'\nshow_cols = ['MouseAge_combined', 'seg_classify', 'phase', 'batch', 'cell_type', \"mes_subtype\", \"dropout_est\"]\nccd.pl.plot_embedding(\n    adata, show_basis, show_cols, figsize=(13,12), dpi=600, ncols=3, font_size=5, point_size=1, legend_loc='on data',\n    save_path=save_dir / f\"{show_basis}_{file_suffix}.png\"\n)\n</pre> #ccd.ul.run_umap(adata, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed) show_basis = f'{output_key}_UMAP' show_cols = ['MouseAge_combined', 'seg_classify', 'phase', 'batch', 'cell_type', \"mes_subtype\", \"dropout_est\"] ccd.pl.plot_embedding(     adata, show_basis, show_cols, figsize=(13,12), dpi=600, ncols=3, font_size=5, point_size=1, legend_loc='on data',     save_path=save_dir / f\"{show_basis}_{file_suffix}.png\" ) <p>It is best to use 3D UMAP rather than 2D to visualize Concord latent, because 2D may not be enough to 'unpack' the complex structures learned by Concord, thus tends to break trajectories.</p> In\u00a0[93]: Copied! <pre>import plotly.io as pio\npio.renderers.default = 'notebook'\nccd.ul.run_umap(adata,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')\n\n# Plot the 3D UMAP embeddings\n#show_cols = ['MouseAge_combined', 'seg_classify', 'phase', 'batch', 'cell_type', \"mes_subtype\"]\ncol = 'cell_type'\nshow_basis = f'{output_key}_UMAP_3D'\nccd.pl.plot_embedding_3d(\n        adata, basis=show_basis, color_by=col,\n        save_path=save_dir / f'{show_basis}_{file_suffix}.html',\n        point_size=1, opacity=0.8, width=1500, height=1000\n    )\n</pre> import plotly.io as pio pio.renderers.default = 'notebook' ccd.ul.run_umap(adata,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')  # Plot the 3D UMAP embeddings #show_cols = ['MouseAge_combined', 'seg_classify', 'phase', 'batch', 'cell_type', \"mes_subtype\"] col = 'cell_type' show_basis = f'{output_key}_UMAP_3D' ccd.pl.plot_embedding_3d(         adata, basis=show_basis, color_by=col,         save_path=save_dir / f'{show_basis}_{file_suffix}.html',         point_size=1, opacity=0.8, width=1500, height=1000     ) <pre>Concord - INFO - UMAP embedding stored in adata.obsm['Concord_UMAP_3D']\nConcord - INFO - 3D plot saved to ../save/dev_concord_Huycke_intestine-Sep29/Concord_UMAP_3D_concord_Huycke_intestine_Sep29.html\n</pre> <p>We can just visualize the Mesenchmal cell (Pdgfra hi/lo) subset, note the loop of cell cycle and the differentiation from Pdgfra-lo to Pdgfra-hi cells.</p> In\u00a0[97]: Copied! <pre>col = 'mes_subtype'\nshow_basis = f'{output_key}_UMAP_3D'\nccd.pl.plot_embedding_3d(\n        adata, basis=show_basis, color_by=col,\n        save_path=save_dir / f'{show_basis}_{file_suffix}.html',\n        point_size=1, opacity=0.8, width=1500, height=800\n    )\n</pre> col = 'mes_subtype' show_basis = f'{output_key}_UMAP_3D' ccd.pl.plot_embedding_3d(         adata, basis=show_basis, color_by=col,         save_path=save_dir / f'{show_basis}_{file_suffix}.html',         point_size=1, opacity=0.8, width=1500, height=800     ) <pre>Concord - INFO - 3D plot saved to ../save/dev_concord_Huycke_intestine-Sep29/Concord_UMAP_3D_concord_Huycke_intestine_Sep29.html\n</pre> In\u00a0[101]: Copied! <pre>obsm_filename = save_dir / f\"obsm_{file_suffix}.h5\"\nccd.ul.save_obsm_to_hdf5(adata, obsm_filename)\nadata.write_h5ad(\"../data/intestine_dev/intestine_adata_concord_{file_suffix}.h5ad\")\n</pre> obsm_filename = save_dir / f\"obsm_{file_suffix}.h5\" ccd.ul.save_obsm_to_hdf5(adata, obsm_filename) adata.write_h5ad(\"../data/intestine_dev/intestine_adata_concord_{file_suffix}.h5ad\") <p>You can optionally convert the result to VisCello (https://github.com/kimpenn/VisCello) for interactive exploration.</p> In\u00a0[\u00a0]: Copied! <pre>ccd.ul.anndata_to_viscello(adata, save_dir / f\"cello_{proj_name}_{file_suffix}\", project_name = proj_name, organism='mmu')\n</pre> ccd.ul.anndata_to_viscello(adata, save_dir / f\"cello_{proj_name}_{file_suffix}\", project_name = proj_name, organism='mmu')"},{"location":"notebooks/concord_Huycke/#basic-setup","title":"Basic setup\u00b6","text":""},{"location":"notebooks/concord_Huycke/#define-feature-input-and-estimate-dropout-rate-in-data","title":"Define feature input and estimate dropout rate in data\u00b6","text":""},{"location":"notebooks/concord_Huycke/#run-concord","title":"Run Concord\u00b6","text":""},{"location":"notebooks/concord_Huycke/#visualize-concord-latent-with-umap","title":"Visualize Concord latent with UMAP\u00b6","text":""},{"location":"notebooks/concord_Huycke/#2d-umap","title":"2D UMAP\u00b6","text":""},{"location":"notebooks/concord_Huycke/#3d-umap","title":"3D UMAP\u00b6","text":""},{"location":"notebooks/concord_Huycke/#save-the-result","title":"Save the result\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/","title":"Mouse organogenesis (100k subset)","text":"<p>Dataset from The single-cell transcriptional landscape of mammalian organogenesis by Cao et al., Nature (2019). This notebook runs on the 100k data subset from https://oncoscape.v3.sttrcancer.org/atlas.gs.washington.edu.mouse.rna/downloads.</p> In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[24]: Copied! <pre>import Concord as ccd\nimport scanpy as sc\nimport torch\nimport warnings\nwarnings.filterwarnings('ignore')\n\ndata_path = \"../data/mouse_organogenesis/adata_sampled_100k.h5ad\"\nadata = sc.read(\n    data_path\n)\nimport pandas as pd\n# Make sure that the gene names are unique\ngene_names = adata.var['gene_short_name']\ngene_names_unique = pd.Series(pd.Index(gene_names)).astype(str)\ngene_names_unique = pd.Index(gene_names_unique.where(~gene_names_unique.duplicated(), gene_names_unique + \"_\" + gene_names_unique.groupby(gene_names_unique).cumcount().astype(str)))\nadata.var_names = gene_names_unique\nadata.var.index.name = None\nadata.layers[\"counts\"] = adata.X.copy()\nsc.pp.normalize_total(adata)\nsc.pp.log1p(adata)\nadata.var\nccd.ul.score_cell_cycle(adata, organism='Mm')\n</pre> import Concord as ccd import scanpy as sc import torch import warnings warnings.filterwarnings('ignore')  data_path = \"../data/mouse_organogenesis/adata_sampled_100k.h5ad\" adata = sc.read(     data_path ) import pandas as pd # Make sure that the gene names are unique gene_names = adata.var['gene_short_name'] gene_names_unique = pd.Series(pd.Index(gene_names)).astype(str) gene_names_unique = pd.Index(gene_names_unique.where(~gene_names_unique.duplicated(), gene_names_unique + \"_\" + gene_names_unique.groupby(gene_names_unique).cumcount().astype(str))) adata.var_names = gene_names_unique adata.var.index.name = None adata.layers[\"counts\"] = adata.X.copy() sc.pp.normalize_total(adata) sc.pp.log1p(adata) adata.var ccd.ul.score_cell_cycle(adata, organism='Mm') <pre>Concord - INFO - Processed 43 human genes to mouse orthologs.\nConcord - INFO - Processed 54 human genes to mouse orthologs.\n</pre> In\u00a0[65]: Copied! <pre># Check GPU availability and cuda version\nimport os\nos.system('nvidia-smi')\n</pre> # Check GPU availability and cuda version import os os.system('nvidia-smi') <pre>Sun Sep 29 16:05:47 2024       \n+---------------------------------------------------------------------------------------+\n| NVIDIA-SMI 535.54.03              Driver Version: 535.54.03    CUDA Version: 12.2     |\n|-----------------------------------------+----------------------+----------------------+\n| GPU  Name                 Persistence-M | Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp   Perf          Pwr:Usage/Cap |         Memory-Usage | GPU-Util  Compute M. |\n|                                         |                      |               MIG M. |\n|=========================================+======================+======================|\n|   0  NVIDIA GeForce GTX 1080        Off | 00000000:02:00.0 Off |                  N/A |\n| 43%   57C    P2              42W / 180W |   7894MiB /  8192MiB |      0%      Default |\n|                                         |                      |                  N/A |\n+-----------------------------------------+----------------------+----------------------+\n|   1  NVIDIA GeForce GTX 1080        Off | 00000000:03:00.0 Off |                  N/A |\n| 28%   19C    P8               6W / 180W |      2MiB /  8192MiB |      0%      Default |\n|                                         |                      |                  N/A |\n+-----------------------------------------+----------------------+----------------------+\n|   2  NVIDIA GeForce GTX 1080        Off | 00000000:81:00.0 Off |                  N/A |\n| 28%   21C    P8               7W / 180W |      2MiB /  8192MiB |      0%      Default |\n|                                         |                      |                  N/A |\n+-----------------------------------------+----------------------+----------------------+\n|   3  NVIDIA GeForce GTX 1080        Off | 00000000:82:00.0 Off |                  N/A |\n| 27%   18C    P8               6W / 180W |      2MiB /  8192MiB |      0%      Default |\n|                                         |                      |                  N/A |\n+-----------------------------------------+----------------------+----------------------+\n                                                                                         \n+---------------------------------------------------------------------------------------+\n| Processes:                                                                            |\n|  GPU   GI   CI        PID   Type   Process name                            GPU Memory |\n|        ID   ID                                                             Usage      |\n|=======================================================================================|\n|    0   N/A  N/A   1480407      C   ...qin/.conda/envs/cellpath/bin/python      670MiB |\n|    0   N/A  N/A   3654886      C   python                                     7222MiB |\n+---------------------------------------------------------------------------------------+\n</pre> Out[65]: <pre>0</pre> In\u00a0[25]: Copied! <pre>import time\nfrom pathlib import Path\nproj_name = \"concord_mouse_organogenesis_100k\"\nsave_dir = f\"../save/dev_{proj_name}-{time.strftime('%b%d')}/\"\nsave_dir = Path(save_dir)\nsave_dir.mkdir(parents=True, exist_ok=True)\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\nfile_suffix = f\"{proj_name}_{time.strftime('%b%d')}\"\nseed = 0\n</pre> import time from pathlib import Path proj_name = \"concord_mouse_organogenesis_100k\" save_dir = f\"../save/dev_{proj_name}-{time.strftime('%b%d')}/\" save_dir = Path(save_dir) save_dir.mkdir(parents=True, exist_ok=True) device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu') file_suffix = f\"{proj_name}_{time.strftime('%b%d')}\" seed = 0 In\u00a0[62]: Copied! <pre>col = 'Main_cell_type'\nshow_basis = f'Original_main_umap'\nccd.ul.ensure_categorical(adata, col)\nccd.pl.plot_embedding_3d(\n        adata, basis=show_basis, color_by=col,\n        save_path=save_dir / f'{show_basis}_{file_suffix}.html',\n        point_size=1, opacity=0.8, width=1500, height=1000\n    )\n</pre> col = 'Main_cell_type' show_basis = f'Original_main_umap' ccd.ul.ensure_categorical(adata, col) ccd.pl.plot_embedding_3d(         adata, basis=show_basis, color_by=col,         save_path=save_dir / f'{show_basis}_{file_suffix}.html',         point_size=1, opacity=0.8, width=1500, height=1000     ) <pre>Concord - INFO - Column 'Main_cell_type' is already of type: category\nConcord - INFO - Unused levels dropped for column 'Main_cell_type'.\n</pre> <pre>Concord - INFO - 3D plot saved to ../save/dev_concord_mouse_organogenesis_100k-Sep29/Original_main_umap_concord_mouse_organogenesis_100k_Sep29.html\n</pre> <p>Dropout is one of the major patterns in single cell data. Even nearby cells can have significant proportion of non-overlapping non-zero genes, which could be due to technical drop-out or real biology (genes stochastically turned on or off). Concord 'augments' the data by introducing dropout to each of the cell, and use contrastive learning to 'self-supervise' the model to learn the cell identity despite the presence of dropout. The augment dropout probability can be custom-defined, or be estimated based on the average dropout rate in the current data. Here we provide a detailed example how this is calculated:</p> In\u00a0[26]: Copied! <pre># Select top variably expressed/accessible features for analysis (other methods besides seurat_v3 available)\noutput_key = 'Concord'\nfeature_list = ccd.ul.select_features(adata, n_top_features=10000, flavor='seurat_v3')\n# Determine augmentation mask probabilities based on estimated dropout rate from knn neighbors\ndropout_est = ccd.ul.estimate_aug_mask_prob(adata, input_feature = feature_list, n_samples = 10000, return_mean=False, plotting=True)\n</pre> # Select top variably expressed/accessible features for analysis (other methods besides seurat_v3 available) output_key = 'Concord' feature_list = ccd.ul.select_features(adata, n_top_features=10000, flavor='seurat_v3') # Determine augmentation mask probabilities based on estimated dropout rate from knn neighbors dropout_est = ccd.ul.estimate_aug_mask_prob(adata, input_feature = feature_list, n_samples = 10000, return_mean=False, plotting=True) <pre>Concord.utils.feature_selector - INFO - Selecting highly variable features with flavor seurat_v3...\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Skip normalization.\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Storing in the specified layer.\nConcord.utils.preprocessor - INFO - Filtering features with provided list (10000 features)...\nConcord - INFO - PCA embedding not found in adata.obsm. Running PCA...\nConcord - INFO - PCA completed.\n</pre> <pre>Concord - INFO - Average feature drop rate of nearest neighbors: 0.664814430564425\n</pre> In\u00a0[33]: Copied! <pre># Use median for concord run\nimport numpy as np\naug_prob = np.median(dropout_est)\n</pre> # Use median for concord run import numpy as np aug_prob = np.median(dropout_est) In\u00a0[38]: Copied! <pre>cross_tab = pd.crosstab(adata.obs['nuclei_extraction_date'], adata.obs['embryo_id'])\ncross_tab\n</pre> cross_tab = pd.crosstab(adata.obs['nuclei_extraction_date'], adata.obs['embryo_id']) cross_tab Out[38]: embryo_id 1 3 4 5 6 7 8 9 10 11 ... 59 60 61 62 63 64 65 66 67 68 nuclei_extraction_date 1 1113 590 900 1656 2000 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 2614 2354 1928 2384 732 ... 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 ... 0 0 0 0 0 0 0 0 0 0 5 0 0 0 0 0 0 0 0 0 0 ... 1843 2474 2557 2456 777 3253 1361 2702 1198 2038 <p>5 rows \u00d7 61 columns</p> <p>Based on the check above, we will use embryo_id as the 'domain_key' for batch integration.</p> In\u00a0[64]: Copied! <pre>cur_ccd = ccd.Concord(adata=adata, \n                      input_feature=feature_list, \n                      domain_key='embryo_id', # \n                      latent_dim=300,\n                      encoder_dims=[1000],\n                      decoder_dims=[1000],\n                      augmentation_mask_prob = aug_prob, \n                      clr_temperature = .5, # Check out advanced usage to learn what this parameter controls\n                      p_intra_domain=1.0, \n                      seed=seed, \n                      inplace=False, \n                      verbose=True, \n                      device=device) \n\n# Encode data, saving the latent embedding in adata.obsm['Concord']\ncur_ccd.encode_adata(input_layer_key='X_log1p', output_key=output_key)\n\n# Save the latent embedding to a filem, so that it can be loaded later\nccd.ul.save_obsm_to_hdf5(cur_ccd.adata, save_dir / f\"obsm_{file_suffix}.h5\")\nadata.obsm = cur_ccd.adata.obsm # If not inplace\n</pre> cur_ccd = ccd.Concord(adata=adata,                        input_feature=feature_list,                        domain_key='embryo_id', #                        latent_dim=300,                       encoder_dims=[1000],                       decoder_dims=[1000],                       augmentation_mask_prob = aug_prob,                        clr_temperature = .5, # Check out advanced usage to learn what this parameter controls                       p_intra_domain=1.0,                        seed=seed,                        inplace=False,                        verbose=True,                        device=device)   # Encode data, saving the latent embedding in adata.obsm['Concord'] cur_ccd.encode_adata(input_layer_key='X_log1p', output_key=output_key)  # Save the latent embedding to a filem, so that it can be loaded later ccd.ul.save_obsm_to_hdf5(cur_ccd.adata, save_dir / f\"obsm_{file_suffix}.h5\") adata.obsm = cur_ccd.adata.obsm # If not inplace <pre>Concord - INFO - Setting sampler_knn to 2000 to be 1/50 the number of cells in the dataset. You can change this value by setting sampler_knn in the configuration.\nConcord - INFO - Column 'embryo_id' is now of type: category\nConcord - INFO - Encoder input dim: 10000\nConcord - INFO - Decoder input dim: 308\nConcord - INFO - Model loaded to device: cuda:0\nConcord - INFO - Total number of parameters: 20635388\nConcord.model.dataloader - INFO - Preprocessing adata...\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Skip normalization.\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Storing in the specified layer.\nConcord.utils.preprocessor - INFO - Filtering features with provided list (10000 features)...\nConcord.model.anndataset - INFO - Initialized dataset with 100000 samples. Data structure: ['input', 'domain', 'idx']\nConcord.model.dataloader - INFO - Using existing embedding 'X_pca' from adata.obsm\nConcord.model.knn - INFO - Using FAISS CPU index.\nConcord.model.knn - INFO - Building Faiss IVF index. nprobe=10\nConcord.model.knn - INFO - Using FAISS CPU index.\nConcord.model.dataloader - INFO - Number of unique_domains: 61\nConcord.model.dataloader - INFO - Final p_intra_domain values: 1: 1.00, 3: 1.00, 4: 1.00, 5: 1.00, 6: 1.00, 7: 1.00, 8: 1.00, 9: 1.00, 10: 1.00, 11: 1.00, 12: 1.00, 13: 1.00, 14: 1.00, 15: 1.00, 16: 1.00, 17: 1.00, 19: 1.00, 20: 1.00, 21: 1.00, 22: 1.00, 24: 1.00, 25: 1.00, 26: 1.00, 27: 1.00, 28: 1.00, 29: 1.00, 31: 1.00, 33: 1.00, 34: 1.00, 35: 1.00, 36: 1.00, 37: 1.00, 38: 1.00, 39: 1.00, 40: 1.00, 41: 1.00, 42: 1.00, 43: 1.00, 44: 1.00, 46: 1.00, 47: 1.00, 48: 1.00, 49: 1.00, 50: 1.00, 51: 1.00, 52: 1.00, 53: 1.00, 55: 1.00, 56: 1.00, 57: 1.00, 58: 1.00, 59: 1.00, 60: 1.00, 61: 1.00, 62: 1.00, 63: 1.00, 64: 1.00, 65: 1.00, 66: 1.00, 67: 1.00, 68: 1.00\nConcord - INFO - Starting epoch 1/5\nConcord - INFO - Processing chunk 1/1 for epoch 1\nConcord - INFO - Number of samples in train_dataloader: 100000\n</pre> <pre>Epoch 0 Training: 1533it [00:57, 26.72it/s, loss=3.74]</pre> <pre>Concord - INFO - Epoch   0 | Train Loss: 3.82, MSE: 0.01, CLASS: 0.00, CONTRAST: 3.81, IMPORTANCE: 0.00\nConcord - INFO - Starting epoch 2/5\nConcord - INFO - Processing chunk 1/1 for epoch 2\nConcord - INFO - Number of samples in train_dataloader: 100000\n</pre> <pre>\nEpoch 1 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1533/1533 [01:03&lt;00:00, 24.24it/s, loss=3.73]</pre> <pre>Concord - INFO - Epoch   1 | Train Loss: 3.66, MSE: 0.01, CLASS: 0.00, CONTRAST: 3.65, IMPORTANCE: 0.00\nConcord - INFO - Starting epoch 3/5\nConcord - INFO - Processing chunk 1/1 for epoch 3\nConcord - INFO - Number of samples in train_dataloader: 100000\n</pre> <pre>\nEpoch 2 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1533/1533 [00:56&lt;00:00, 27.32it/s, loss=3.69]</pre> <pre>Concord - INFO - Epoch   2 | Train Loss: 3.63, MSE: 0.01, CLASS: 0.00, CONTRAST: 3.62, IMPORTANCE: 0.00\nConcord - INFO - Starting epoch 4/5\nConcord - INFO - Processing chunk 1/1 for epoch 4\nConcord - INFO - Number of samples in train_dataloader: 100000\n</pre> <pre>\nEpoch 3 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1533/1533 [00:59&lt;00:00, 25.69it/s, loss=3.67]</pre> <pre>Concord - INFO - Epoch   3 | Train Loss: 3.61, MSE: 0.01, CLASS: 0.00, CONTRAST: 3.60, IMPORTANCE: 0.00\n</pre> <pre>\n</pre> <pre>Concord - INFO - Starting epoch 5/5\nConcord - INFO - Processing chunk 1/1 for epoch 5\nConcord - INFO - Number of samples in train_dataloader: 100000\n</pre> <pre>Epoch 4 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1533/1533 [00:52&lt;00:00, 29.00it/s, loss=3.53]</pre> <pre>Concord - INFO - Epoch   4 | Train Loss: 3.59, MSE: 0.01, CLASS: 0.00, CONTRAST: 3.58, IMPORTANCE: 0.00\n</pre> <pre>\n</pre> <pre>Concord - INFO - Model saved to save/final_model.pth\nConcord - INFO - Final model saved at: save/final_model.pth; Configuration saved at: save/config.json.\nConcord.model.dataloader - INFO - Preprocessing adata...\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Skip normalization.\nConcord.utils.preprocessor - INFO - Data is already log1p transformed. Storing in the specified layer.\nConcord.utils.preprocessor - INFO - Filtering features with provided list (10000 features)...\nConcord.model.anndataset - INFO - Initialized dataset with 100000 samples. Data structure: ['input', 'domain', 'idx']\nConcord - INFO - Predicting for chunk 1/1\n</pre> In\u00a0[69]: Copied! <pre>ccd.ul.run_umap(adata, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed)\nshow_basis = f'{output_key}_UMAP'\nshow_cols = ['embryo_id', 'embryo_sex', 'development_stage', 'num_genes_expressed', 'Main_cell_type', 'Main_trajectory', 'Sub_trajectory_name', 'Sub_trajectory_Pseudotime', 'phase']\nccd.pl.plot_embedding(\n    adata, show_basis, show_cols, figsize=(13,11), dpi=600, ncols=3, font_size=5, point_size=.5, legend_loc='on data',\n    save_path=save_dir / f\"{show_basis}_{file_suffix}.png\"\n)\n</pre> ccd.ul.run_umap(adata, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed) show_basis = f'{output_key}_UMAP' show_cols = ['embryo_id', 'embryo_sex', 'development_stage', 'num_genes_expressed', 'Main_cell_type', 'Main_trajectory', 'Sub_trajectory_name', 'Sub_trajectory_Pseudotime', 'phase'] ccd.pl.plot_embedding(     adata, show_basis, show_cols, figsize=(13,11), dpi=600, ncols=3, font_size=5, point_size=.5, legend_loc='on data',     save_path=save_dir / f\"{show_basis}_{file_suffix}.png\" ) <p>It is best to use 3D UMAP rather than 2D to visualize Concord latent, because 2D may not be enough to 'unpack' the complex structures learned by Concord, thus tends to break trajectories.</p> In\u00a0[70]: Copied! <pre>import plotly.io as pio\npio.renderers.default = 'notebook'\nccd.ul.run_umap(adata,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')\n\n# Plot the 3D UMAP embeddings\ncol = 'Main_cell_type'\nshow_basis = f'{output_key}_UMAP_3D'\nccd.pl.plot_embedding_3d(\n        adata, basis=show_basis, color_by=col,\n        save_path=save_dir / f'{show_basis}_{file_suffix}.html',\n        point_size=1, opacity=0.8, width=1500, height=1000\n    )\n</pre> import plotly.io as pio pio.renderers.default = 'notebook' ccd.ul.run_umap(adata,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')  # Plot the 3D UMAP embeddings col = 'Main_cell_type' show_basis = f'{output_key}_UMAP_3D' ccd.pl.plot_embedding_3d(         adata, basis=show_basis, color_by=col,         save_path=save_dir / f'{show_basis}_{file_suffix}.html',         point_size=1, opacity=0.8, width=1500, height=1000     ) <pre>Concord - INFO - UMAP embedding stored in adata.obsm['Concord_UMAP_3D']\nConcord - INFO - 3D plot saved to ../save/dev_concord_mouse_organogenesis_100k-Sep29/Concord_UMAP_3D_concord_mouse_organogenesis_100k_Sep29.html\n</pre> <p>Concord is able to learn both local and global structure. This means Concord have much higher resolution for each cell type in the dataset, and you can simply re-run UMAP on the global-learned latent of that cell type (without re-run Concord on that subset) to see the detailed structure for that cell type (which sometimes global UMAP cannot correctly embed). Here we demonstrate with two main trajectories: Mesenchymal trajectory and Neural tube and notochord trajectory.</p> <p>In practice, it is still recommended to subset and then run Concord because if you use variably expressed gene (VEG) selection for Concord input, it will further enrich for more cell sub-type specific genes/signals to enable even greater resolution within a cell type.</p> In\u00a0[84]: Copied! <pre>adata.obs['Main_trajectory'].value_counts()\n</pre> adata.obs['Main_trajectory'].value_counts() Out[84]: <pre>Main_trajectory\nMesenchymal trajectory                  43846\nNeural tube and notochord trajectory    41217\nEpithelial trajectory                    5144\nHaematopoiesis trajectory                3267\nEndothelial trajectory                   1918\nNeural crest 1                           1905\nNeural crest 2                           1676\nHepatocyte trajectory                     868\nNeural crest 3                            111\nLens trajectory                            48\nName: count, dtype: int64</pre> In\u00a0[\u00a0]: Copied! <pre>show_traj = 'Mesenchymal trajectory'\nadata_sub = adata[adata.obs['Main_trajectory'] == show_traj]\nccd.ul.run_umap(adata_sub, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed)\nshow_basis = f'{output_key}_UMAP'\nshow_cols = ['embryo_id', 'embryo_sex', 'development_stage', 'num_genes_expressed', 'Main_cell_type', 'Main_trajectory', 'Sub_trajectory_name', 'Sub_trajectory_Pseudotime', 'phase']\nccd.pl.plot_embedding(\n    adata_sub, show_basis, show_cols, figsize=(13,11), dpi=600, ncols=3, font_size=5, point_size=1, legend_loc='on data',\n    save_path=save_dir / f\"{show_traj.replace(' ', '_')}_{show_basis}_{file_suffix}.png\"\n)\n# output cleared due to github file size limit\n</pre> show_traj = 'Mesenchymal trajectory' adata_sub = adata[adata.obs['Main_trajectory'] == show_traj] ccd.ul.run_umap(adata_sub, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed) show_basis = f'{output_key}_UMAP' show_cols = ['embryo_id', 'embryo_sex', 'development_stage', 'num_genes_expressed', 'Main_cell_type', 'Main_trajectory', 'Sub_trajectory_name', 'Sub_trajectory_Pseudotime', 'phase'] ccd.pl.plot_embedding(     adata_sub, show_basis, show_cols, figsize=(13,11), dpi=600, ncols=3, font_size=5, point_size=1, legend_loc='on data',     save_path=save_dir / f\"{show_traj.replace(' ', '_')}_{show_basis}_{file_suffix}.png\" ) # output cleared due to github file size limit In\u00a0[103]: Copied! <pre>ccd.ul.run_umap(adata_sub,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')\n\n# Plot the 3D UMAP embeddings\ncol = 'Main_cell_type'\nshow_basis = f'{output_key}_UMAP_3D'\nccd.pl.plot_embedding_3d(\n        adata_sub, basis=show_basis, color_by=col,\n        save_path=save_dir / f\"{show_traj.replace(' ', '_')}_{show_basis}_{file_suffix}.html\",\n        point_size=1, opacity=0.8, width=1500, height=1000\n    )\n# output cleared due to github size limit\n</pre> ccd.ul.run_umap(adata_sub,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')  # Plot the 3D UMAP embeddings col = 'Main_cell_type' show_basis = f'{output_key}_UMAP_3D' ccd.pl.plot_embedding_3d(         adata_sub, basis=show_basis, color_by=col,         save_path=save_dir / f\"{show_traj.replace(' ', '_')}_{show_basis}_{file_suffix}.html\",         point_size=1, opacity=0.8, width=1500, height=1000     ) # output cleared due to github size limit In\u00a0[\u00a0]: Copied! <pre>show_traj = 'Neural tube and notochord trajectory'\nadata_sub = adata[adata.obs['Main_trajectory'] == show_traj]\nccd.ul.run_umap(adata_sub, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed)\nshow_basis = f'{output_key}_UMAP'\nshow_cols = ['embryo_id', 'embryo_sex', 'development_stage', 'num_genes_expressed', 'Main_cell_type', 'Main_trajectory', 'Sub_trajectory_name', 'Sub_trajectory_Pseudotime', 'phase']\nccd.pl.plot_embedding(\n    adata_sub, show_basis, show_cols, figsize=(13,11), dpi=600, ncols=3, font_size=5, point_size=1, legend_loc='on data',\n    save_path=save_dir / f\"{show_traj.replace(' ', '_')}_{show_basis}_{file_suffix}.png\"\n)\n# output cleared due to github file size limit\n</pre> show_traj = 'Neural tube and notochord trajectory' adata_sub = adata[adata.obs['Main_trajectory'] == show_traj] ccd.ul.run_umap(adata_sub, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed) show_basis = f'{output_key}_UMAP' show_cols = ['embryo_id', 'embryo_sex', 'development_stage', 'num_genes_expressed', 'Main_cell_type', 'Main_trajectory', 'Sub_trajectory_name', 'Sub_trajectory_Pseudotime', 'phase'] ccd.pl.plot_embedding(     adata_sub, show_basis, show_cols, figsize=(13,11), dpi=600, ncols=3, font_size=5, point_size=1, legend_loc='on data',     save_path=save_dir / f\"{show_traj.replace(' ', '_')}_{show_basis}_{file_suffix}.png\" ) # output cleared due to github file size limit In\u00a0[105]: Copied! <pre>ccd.ul.run_umap(adata_sub,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')\n\n# Plot the 3D UMAP embeddings\ncol = 'Main_cell_type'\nshow_basis = f'{output_key}_UMAP_3D'\nccd.pl.plot_embedding_3d(\n        adata_sub, basis=show_basis, color_by=col,\n        save_path=save_dir / f\"{show_traj.replace(' ', '_')}_{show_basis}_{file_suffix}.html\",\n        point_size=1, opacity=0.8, width=1500, height=1000\n    )\n</pre> ccd.ul.run_umap(adata_sub,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')  # Plot the 3D UMAP embeddings col = 'Main_cell_type' show_basis = f'{output_key}_UMAP_3D' ccd.pl.plot_embedding_3d(         adata_sub, basis=show_basis, color_by=col,         save_path=save_dir / f\"{show_traj.replace(' ', '_')}_{show_basis}_{file_suffix}.html\",         point_size=1, opacity=0.8, width=1500, height=1000     ) In\u00a0[98]: Copied! <pre>feature_list = ccd.ul.select_features(adata_sub, n_top_features=10000, flavor='seurat_v3')\nsub_ccd = ccd.Concord(adata=adata_sub, \n                      input_feature=feature_list, \n                      domain_key='embryo_id', # \n                      latent_dim=100,\n                      encoder_dims=[1000],\n                      decoder_dims=[1000],\n                      augmentation_mask_prob = aug_prob, \n                      clr_temperature = .5, # Check out advanced usage to learn what this parameter controls\n                      p_intra_domain=1.0, \n                      seed=seed, \n                      inplace=False, \n                      verbose=False, \n                      device=device) \n\n# Encode data, saving the latent embedding in adata.obsm['Concord']\nsub_ccd.encode_adata(input_layer_key='X_log1p', output_key=output_key)\n\n# Save the latent embedding to a filem, so that it can be loaded later\nccd.ul.save_obsm_to_hdf5(sub_ccd.adata, save_dir / f\"obsm_{show_traj.replace(' ', '_')}_{file_suffix}.h5\")\nadata_sub.obsm = sub_ccd.adata.obsm # If not inplace\n</pre> feature_list = ccd.ul.select_features(adata_sub, n_top_features=10000, flavor='seurat_v3') sub_ccd = ccd.Concord(adata=adata_sub,                        input_feature=feature_list,                        domain_key='embryo_id', #                        latent_dim=100,                       encoder_dims=[1000],                       decoder_dims=[1000],                       augmentation_mask_prob = aug_prob,                        clr_temperature = .5, # Check out advanced usage to learn what this parameter controls                       p_intra_domain=1.0,                        seed=seed,                        inplace=False,                        verbose=False,                        device=device)   # Encode data, saving the latent embedding in adata.obsm['Concord'] sub_ccd.encode_adata(input_layer_key='X_log1p', output_key=output_key)  # Save the latent embedding to a filem, so that it can be loaded later ccd.ul.save_obsm_to_hdf5(sub_ccd.adata, save_dir / f\"obsm_{show_traj.replace(' ', '_')}_{file_suffix}.h5\") adata_sub.obsm = sub_ccd.adata.obsm # If not inplace <pre>Epoch 0 Training: 615it [00:23, 26.40it/s, loss=3.85]\nEpoch 1 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 615/615 [00:20&lt;00:00, 29.47it/s, loss=3.96]\nEpoch 2 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 615/615 [00:20&lt;00:00, 29.96it/s, loss=3.57]\nEpoch 3 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 615/615 [00:20&lt;00:00, 29.69it/s, loss=3.52]\nEpoch 4 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 615/615 [00:20&lt;00:00, 29.74it/s, loss=3.76]\n</pre> In\u00a0[99]: Copied! <pre>show_traj = 'Neural tube and notochord trajectory'\nccd.ul.run_umap(adata_sub, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed)\nshow_basis = f'{output_key}_UMAP'\nshow_cols = ['embryo_id', 'embryo_sex', 'development_stage', 'num_genes_expressed', 'Main_cell_type', 'Main_trajectory', 'Sub_trajectory_name', 'Sub_trajectory_Pseudotime', 'phase']\nccd.pl.plot_embedding(\n    adata_sub, show_basis, show_cols, figsize=(13,11), dpi=600, ncols=3, font_size=5, point_size=1, legend_loc='on data',\n    save_path=save_dir / f\"{show_traj.replace(' ', '_')}_concord_zoom_{show_basis}_{file_suffix}.png\"\n)\n</pre> show_traj = 'Neural tube and notochord trajectory' ccd.ul.run_umap(adata_sub, source_key=output_key, umap_key=f'{output_key}_UMAP', n_components=2, n_neighbors=30, min_dist=0.1, metric='euclidean', random_state=seed) show_basis = f'{output_key}_UMAP' show_cols = ['embryo_id', 'embryo_sex', 'development_stage', 'num_genes_expressed', 'Main_cell_type', 'Main_trajectory', 'Sub_trajectory_name', 'Sub_trajectory_Pseudotime', 'phase'] ccd.pl.plot_embedding(     adata_sub, show_basis, show_cols, figsize=(13,11), dpi=600, ncols=3, font_size=5, point_size=1, legend_loc='on data',     save_path=save_dir / f\"{show_traj.replace(' ', '_')}_concord_zoom_{show_basis}_{file_suffix}.png\" ) In\u00a0[100]: Copied! <pre>ccd.ul.run_umap(adata_sub,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=30, min_dist=0.1, metric='euclidean')\n\n# Plot the 3D UMAP embeddings\ncol = 'Main_cell_type'\nshow_basis = f'{output_key}_UMAP_3D'\nccd.pl.plot_embedding_3d(\n        adata_sub, basis=show_basis, color_by=col,\n        save_path=save_dir / f\"{show_traj.replace(' ', '_')}_concord_zoom_{show_basis}_{file_suffix}.html\",\n        point_size=1, opacity=0.8, width=1500, height=1000\n    )\n</pre> ccd.ul.run_umap(adata_sub,  source_key=output_key, umap_key=f'{output_key}_UMAP_3D', n_components=3, n_neighbors=30, min_dist=0.1, metric='euclidean')  # Plot the 3D UMAP embeddings col = 'Main_cell_type' show_basis = f'{output_key}_UMAP_3D' ccd.pl.plot_embedding_3d(         adata_sub, basis=show_basis, color_by=col,         save_path=save_dir / f\"{show_traj.replace(' ', '_')}_concord_zoom_{show_basis}_{file_suffix}.html\",         point_size=1, opacity=0.8, width=1500, height=1000     ) In\u00a0[80]: Copied! <pre>obsm_filename = save_dir / f\"obsm_{file_suffix}.h5\"\nccd.ul.save_obsm_to_hdf5(adata, obsm_filename)\nadata.write_h5ad(f\"../data/mouse_organogenesis/{proj_name}_concord_{file_suffix}.h5ad\")\n</pre> obsm_filename = save_dir / f\"obsm_{file_suffix}.h5\" ccd.ul.save_obsm_to_hdf5(adata, obsm_filename) adata.write_h5ad(f\"../data/mouse_organogenesis/{proj_name}_concord_{file_suffix}.h5ad\") <p>You can optionally convert the result to VisCello (https://github.com/kimpenn/VisCello) for interactive exploration.</p> In\u00a0[83]: Copied! <pre>ccd.ul.anndata_to_viscello(adata, save_dir / f\"cello_{proj_name}_{file_suffix}\", project_name = proj_name, organism='mmu')\n</pre> ccd.ul.anndata_to_viscello(adata, save_dir / f\"cello_{proj_name}_{file_suffix}\", project_name = proj_name, organism='mmu') <pre>VisCello project created at ../save/dev_concord_mouse_organogenesis_100k-Sep29/cello_concord_mouse_organogenesis_100k_concord_mouse_organogenesis_100k_Sep29\n</pre>"},{"location":"notebooks/concord_mouse_organogenesis_100k/#mouse-organogenesis-100k-subset","title":"Mouse organogenesis (100k subset)\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#basic-setup","title":"Basic setup\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#original-umap","title":"Original UMAP\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#define-feature-input-and-estimate-dropout-rate-in-data","title":"Define feature input and estimate dropout rate in data\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#run-concord","title":"Run Concord\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#visualize-concord-latent-with-umap","title":"Visualize Concord latent with UMAP\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#2d-umap","title":"2D UMAP\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#3d-umap","title":"3D UMAP\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#zoom-in-to-sub-trajectories-without-rerunning-concord","title":"Zoom in to sub-trajectories without rerunning Concord\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#mesenchymal-trajectory-global-latent","title":"Mesenchymal trajectory (Global latent)\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#neural-tube-and-notochord-trajectory-global-latent","title":"Neural tube and notochord trajectory (Global latent)\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#neural-tube-and-notochord-trajectory-re-run-concord-on-subset","title":"Neural tube and notochord trajectory (Re-run Concord on subset)\u00b6","text":""},{"location":"notebooks/concord_mouse_organogenesis_100k/#save-the-result","title":"Save the result\u00b6","text":""},{"location":"notebooks/concord_pbmc3k/","title":"PBMC3k dataset, single batch","text":"In\u00a0[5]: Copied! <pre>import Concord as ccd\nimport scanpy as sc\nimport torch\nimport warnings\nwarnings.filterwarnings('ignore')\n\nadata = sc.datasets.pbmc3k_processed()\nadata = adata.raw.to_adata()  # Store raw counts in adata.X, by default Concord will run standard total count normalization and log transformation internally\n\n# Set device to cpu or to gpu (if your torch has been set up correctly to use GPU)\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n\n# Select top variably expressed/accessible features for analysis (other methods besides seurat_v3 available)\nfeature_list = ccd.ul.select_features(adata, n_top_features=5000, flavor='seurat_v3')\n\n# Initialize Concord with an AnnData object, skip input_feature default to all features\ncur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, device=device, use_faiss=False, verbose=False) \n# If integrating data across batch, simply add the domain_key argument\n# cur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, domain_key='batch', device=device) \n\n# Encode data, saving the latent embedding in adata.obsm['Concord']\ncur_ccd.encode_adata(input_layer_key='X_log1p', output_key='Concord')\n</pre> import Concord as ccd import scanpy as sc import torch import warnings warnings.filterwarnings('ignore')  adata = sc.datasets.pbmc3k_processed() adata = adata.raw.to_adata()  # Store raw counts in adata.X, by default Concord will run standard total count normalization and log transformation internally  # Set device to cpu or to gpu (if your torch has been set up correctly to use GPU) device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')  # Select top variably expressed/accessible features for analysis (other methods besides seurat_v3 available) feature_list = ccd.ul.select_features(adata, n_top_features=5000, flavor='seurat_v3')  # Initialize Concord with an AnnData object, skip input_feature default to all features cur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, device=device, use_faiss=False, verbose=False)  # If integrating data across batch, simply add the domain_key argument # cur_ccd = ccd.Concord(adata=adata, input_feature=feature_list, domain_key='batch', device=device)   # Encode data, saving the latent embedding in adata.obsm['Concord'] cur_ccd.encode_adata(input_layer_key='X_log1p', output_key='Concord') <pre>Concord.utils.feature_selector - INFO - Selecting highly variable features with flavor seurat_v3...\nConcord - WARNING - domain/batch information not found, all samples will be treated as from single domain/batch.\nConcord.model.dataloader - WARNING - Only one domain found in the data. Setting p_intra_domain to 1.0.\n</pre> <pre>Epoch 0 Training: 41it [00:01, 38.28it/s, loss=4.35]\nEpoch 1 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 41/41 [00:01&lt;00:00, 39.48it/s, loss=4.21]\nEpoch 2 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 41/41 [00:01&lt;00:00, 36.56it/s, loss=4.06]\nEpoch 3 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 41/41 [00:01&lt;00:00, 39.58it/s, loss=4.03]\nEpoch 4 Training: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 41/41 [00:00&lt;00:00, 41.87it/s, loss=4.1] \n</pre> In\u00a0[6]: Copied! <pre>ccd.ul.run_umap(adata, source_key='Concord', umap_key='Concord_UMAP', n_components=2, n_neighbors=15, min_dist=0.1, metric='euclidean')\n\n# Plot the UMAP embeddings\ncolor_by = ['n_genes', 'louvain'] # Choose which variables you want to visualize\nccd.pl.plot_embedding(\n    adata, basis='Concord_UMAP', color_by=color_by, figsize=(8, 4), dpi=600, ncols=2, font_size=6, point_size=10, legend_loc='on data',\n    save_path='Concord_UMAP.png'\n)\n</pre> ccd.ul.run_umap(adata, source_key='Concord', umap_key='Concord_UMAP', n_components=2, n_neighbors=15, min_dist=0.1, metric='euclidean')  # Plot the UMAP embeddings color_by = ['n_genes', 'louvain'] # Choose which variables you want to visualize ccd.pl.plot_embedding(     adata, basis='Concord_UMAP', color_by=color_by, figsize=(8, 4), dpi=600, ncols=2, font_size=6, point_size=10, legend_loc='on data',     save_path='Concord_UMAP.png' ) <p>We can compare to UMAP by scanpy:</p> In\u00a0[7]: Copied! <pre>ccd.pl.plot_embedding(\n    adata, basis='X_umap', color_by=color_by, figsize=(8, 4), dpi=600, ncols=2, font_size=6, point_size=10, legend_loc='on data',\n    save_path='X_umap.png'\n)\n</pre> ccd.pl.plot_embedding(     adata, basis='X_umap', color_by=color_by, figsize=(8, 4), dpi=600, ncols=2, font_size=6, point_size=10, legend_loc='on data',     save_path='X_umap.png' ) <p>Concord result is best visualized with 3D UMAPs because 2D UMAP sometimes is not enough to unpack the learned latent structures:</p> In\u00a0[8]: Copied! <pre>import plotly.io as pio\npio.renderers.default = 'notebook'\nccd.ul.run_umap(adata, source_key='Concord', umap_key='Concord_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')\n\n# Plot the 3D UMAP embeddings\ncol = 'louvain'\nccd.pl.plot_embedding_3d(\n    adata, basis='Concord_UMAP_3D', color_by=col,\n    save_path='Concord_UMAP_3D.html',\n    point_size=1, opacity=0.8, width=1200, height=800\n)\n</pre> import plotly.io as pio pio.renderers.default = 'notebook' ccd.ul.run_umap(adata, source_key='Concord', umap_key='Concord_UMAP_3D', n_components=3, n_neighbors=15, min_dist=0.1, metric='euclidean')  # Plot the 3D UMAP embeddings col = 'louvain' ccd.pl.plot_embedding_3d(     adata, basis='Concord_UMAP_3D', color_by=col,     save_path='Concord_UMAP_3D.html',     point_size=1, opacity=0.8, width=1200, height=800 )"}]}